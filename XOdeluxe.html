<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Tic Tac Toe Deluxe</title>
<script src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script src="https://cdn.tailwindcss.com"></script>
<script>tailwind.config={darkMode:'class'};</script>
<style>
  .cell-animate{transition:transform .2s ease}
  .cell-animate:active{transform:scale(.96)}
  @keyframes spin3D{0%{transform:rotateY(0)}100%{transform:rotateY(360deg)}}
  .win-spin{animation:spin3D 1s linear infinite;display:inline-block}
  @keyframes popAnim{0%{transform:scale(.5);opacity:0}60%{transform:scale(1.2);opacity:1}100%{transform:scale(1)}}
  .pop{animation:popAnim .22s ease;display:inline-block}
  /* 3D-ish chunky mark */
  .mark-3d{
    text-shadow:
      0 1px 0 rgba(0,0,0,.25),
      0 2px 0 rgba(0,0,0,.20),
      0 3px 0 rgba(0,0,0,.15),
      0 4px 0 rgba(0,0,0,.10);
    transform: translateZ(0); /* enable GPU */
  }
</style>
</head>
<body class="min-h-screen bg-gray-50 text-gray-900 dark:bg-slate-900 dark:text-slate-100 flex justify-center p-4">
<div id="root" class="w-full max-w-5xl"></div>

<script type="text/babel">
const { useState, useEffect, useMemo, useRef } = React;

/* --- Tiny SVG Tally component --- */
function Tally({ count, color }) {
  // Groups of 5: four verticals + one diagonal slash
  const groups = Math.floor(count / 5);
  const rem = count % 5;
  const OneGroup = ({ n }) => {
    const w = 48, h = 28;
    const xs = [6, 14, 22, 30]; // vertical lines
    return (
      <svg width={w} height={h} viewBox={`0 0 ${w} ${h}`} className="mr-1">
        {/* verticals */}
        {xs.slice(0, Math.min(n,4)).map((x,i)=>(
          <line key={i} x1={x} y1="4" x2={x} y2="24" stroke={color} strokeWidth="3" strokeLinecap="round" />
        ))}
        {/* diagonal when n==5 */}
        {n===5 && (
          <line x1="3" y1="23" x2="33" y2="5" stroke={color} strokeWidth="3" strokeLinecap="round" />
        )}
      </svg>
    );
  };
  return (
    <div className="flex flex-wrap items-center">
      {Array.from({length: groups}).map((_,i)=><OneGroup key={i} n={5} />)}
      {rem>0 && <OneGroup n={rem} />}
    </div>
  );
}

function TicTacToe(){
  const EMPTY = Array(9).fill(null);

  // Board/turn & starter
  const [board, setBoard] = useState(EMPTY);
  const [xIsNext, setXIsNext] = useState(true);          // X turn?
  const [starterMark, setStarterMark] = useState('X');    // who starts NEXT round

  // Players (Human X; if AI enabled, AI plays O)
  const [player1, setPlayer1] = useState(localStorage.getItem("player1")||"Player 1"); // X
  const [player2, setPlayer2] = useState(localStorage.getItem("player2")||"Player 2"); // O
  const [colorX, setColorX]   = useState(localStorage.getItem("colorX")||"#06b6d4");
  const [colorO, setColorO]   = useState(localStorage.getItem("colorO")||"#3b82f6");

  // Meta
  const [scores, setScores]   = useState(JSON.parse(localStorage.getItem("scores"))||{});
  const [streaks, setStreaks] = useState(JSON.parse(localStorage.getItem("streaks"))||{});
  const [streakHolder, setStreakHolder] = useState(null);
  const [currentStreak, setCurrentStreak] = useState(0);
  const [playAI, setPlayAI] = useState(localStorage.getItem("playAI")==="true");
  const [difficulty, setDifficulty] = useState(localStorage.getItem("difficulty")||"Beginner");
  const [darkMode, setDarkMode] = useState(localStorage.getItem("theme")==="dark");
  const [winningLine, setWinningLine] = useState([]);
  const [justPlaced, setJustPlaced] = useState(null);
  const [statusMsg, setStatusMsg] = useState("");

  // Sounds
  const [soundOn, setSoundOn] = useState(localStorage.getItem("soundOn")!=="false");
  const audioCtxRef = useRef(null);
  function ensureAudio(){
    if (!audioCtxRef.current) audioCtxRef.current = new (window.AudioContext||window.webkitAudioContext)();
    if (audioCtxRef.current.state === "suspended") audioCtxRef.current.resume();
  }
  function beep(freq=440, dur=120, type='sine', vol=0.05){
    if (!soundOn) return;
    ensureAudio();
    const ctx = audioCtxRef.current;
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = type; o.frequency.value = freq; g.gain.value = vol;
    o.connect(g); g.connect(ctx.destination);
    const now = ctx.currentTime;
    o.start(now);
    g.gain.setValueAtTime(vol, now);
    g.gain.exponentialRampToValueAtTime(0.0001, now + dur/1000);
    o.stop(now + dur/1000 + 0.01);
  }
  function moveSound(mark){ beep(mark==='X' ? 880 : 660, 90, 'triangle', 0.04); }
  function drawSound(){ beep(440,120); setTimeout(()=>beep(392,120),120); }
  function winSound(){ beep(523.25,110); setTimeout(()=>beep(659.25,110),110); setTimeout(()=>beep(783.99,160),220); }

  // Persist settings
  useEffect(()=>{
    localStorage.setItem("player1",player1);
    localStorage.setItem("player2",player2);
    localStorage.setItem("colorX",colorX);
    localStorage.setItem("colorO",colorO);
    localStorage.setItem("scores",JSON.stringify(scores));
    localStorage.setItem("streaks",JSON.stringify(streaks));
    localStorage.setItem("playAI",playAI);
    localStorage.setItem("difficulty",difficulty);
    localStorage.setItem("theme",darkMode?"dark":"light");
    localStorage.setItem("soundOn", String(soundOn));
  },[player1,player2,colorX,colorO,scores,streaks,playAI,difficulty,darkMode,soundOn]);

  useEffect(()=>{ document.documentElement.classList.toggle("dark",darkMode); },[darkMode]);

  function vibrate(ms){ if (navigator.vibrate) navigator.vibrate(ms); }

  // Winner detection
  function calculateWinner(brd){
    const lines = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
    for (const [i,j,k] of lines){
      if (brd[i] && brd[i]===brd[j] && brd[i]===brd[k]) return {winner: brd[i], line:[i,j,k]};
    }
    return null;
  }

  const result = useMemo(()=>calculateWinner(board),[board]);
  const isDraw = useMemo(()=>!result && !board.includes(null),[result,board]);
  const gameOver = !!result || isDraw;

  // AI helpers
  function blockOrWinMove(mark, opp, brd){
    const lines = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
    // Try to win
    for (const [i,j,k] of lines){ const L=[brd[i],brd[j],brd[k]]; if (L.filter(v=>v===mark).length===2 && L.includes(null)) return [i,j,k][L.indexOf(null)]; }
    // Otherwise block
    for (const [i,j,k] of lines){ const L=[brd[i],brd[j],brd[k]]; if (L.filter(v=>v===opp ).length===2 && L.includes(null)) return [i,j,k][L.indexOf(null)]; }
    return null;
  }

  function minimax(brd, isMax, ai, human){
    const r = calculateWinner(brd);
    if (r?.winner===ai) return {score:1};
    if (r?.winner===human) return {score:-1};
    if (!brd.includes(null)) return {score:0};
    let best = {score: isMax? -Infinity : Infinity, move:null};
    for (let idx=0; idx<9; idx++){
      if (!brd[idx]){
        brd[idx] = isMax ? ai : human;
        const s = minimax(brd, !isMax, ai, human).score;
        brd[idx] = null;
        if (isMax ? s>best.score : s<best.score) best = {score:s, move:idx};
      }
    }
    return best;
  }

  function aiChooseMove(currentBoard){
    const ai='O', human='X';
    let move=null;
    if (difficulty==="Expert"){
      move = minimax([...currentBoard], true, ai, human).move;
    } else {
      const rand = (difficulty==="Beginner") ? 0.75 : 0.5;
      if (Math.random() < rand){
        const empty = currentBoard.map((v,i)=>v?null:i).filter(v=>v!==null);
        move = empty[Math.floor(Math.random()*empty.length)];
      } else {
        move = blockOrWinMove(ai, human, currentBoard);
        if (move===null){
          const empty = currentBoard.map((v,i)=>v?null:i).filter(v=>v!==null);
          move = empty[Math.floor(Math.random()*empty.length)];
        }
      }
    }
    return move;
  }

  // AI acts only when AI's turn (O), and only in AI mode, and only if game not over
  useEffect(()=>{
    if (!playAI || gameOver || xIsNext) return;
    const id = setTimeout(()=>{
      const move = aiChooseMove(board);
      if (move!=null) placeMark(move, true);
    }, 260);
    return ()=>clearTimeout(id);
  }, [board, xIsNext, playAI, gameOver, difficulty]);

  function endRound(r){
    if (r){ // win
      vibrate(110); winSound();
      setWinningLine(r.line);
      const winnerName = r.winner==="X" ? player1 : player2;
      setStatusMsg(`${winnerName} wins!`);
      setScores(s=>({...s, [winnerName]:(s[winnerName]||0)+1}));
      if (streakHolder===winnerName) setCurrentStreak(cs=>cs+1);
      else { setStreakHolder(winnerName); setCurrentStreak(1); }
      setStreaks(st=>({...st, [winnerName]:Math.max(st[winnerName]||0, (streakHolder===winnerName? currentStreak+1 : 1))}));
      setStarterMark(r.winner); // winner starts next
    } else { // draw
      vibrate(60); drawSound();
      setStatusMsg(`It's a draw.`);
      setStarterMark(m => (m==='X' ? 'O' : 'X')); // alternate on draw (based on starter)
    }
  }

  function placeMark(i, fromAI=false){
    if (board[i] || gameOver) return;
    const next = [...board];
    const mark = xIsNext ? "X" : "O";
    next[i] = mark;
    setBoard(next);
    setJustPlaced(i);
    vibrate(25); moveSound(mark);

    const r = calculateWinner(next);
    if (r || !next.includes(null)){ endRound(r); return; }
    setStatusMsg("");
    setXIsNext(v=>!v);
  }

  // PvP: both players click; AI mode: only human (X) clicks
  function onCellClick(i){
    if (playAI){
      if (xIsNext) placeMark(i, false); // only human can click
    } else {
      placeMark(i, false);              // PvP allows either side on their turn
    }
  }

  function nextRound(){
    setBoard(EMPTY);
    setWinningLine([]);
    setJustPlaced(null);
    setStatusMsg("");
    setXIsNext(starterMark==='X'); // if O starts & AI on, AI moves via effect
  }

  function resetScores(){
    setScores({});
    setStreaks({});      // optional: wipe streaks with score reset
    setCurrentStreak(0);
    setStreakHolder(null);
  }

  const turnName = xIsNext ? player1 : player2;
  const themeBtnText = darkMode ? "Switch to Light Mode" : "Switch to Dark Mode";

  /* Layout: board left, sidebar right (stacks on mobile) */
  return (
    <div className="w-full">
      <div className="flex flex-col lg:flex-row gap-6">
        {/* LEFT: Board + controls */}
        <div className="flex-1">
          <h1 className="text-3xl font-extrabold text-center mb-1">Tic Tac Toe Deluxe</h1>
          <p className="text-center mb-3">Turn: <span className="font-semibold">{turnName}</span></p>
          {statusMsg && <p className="text-center font-semibold mb-3">{statusMsg}</p>}

          <div className="flex items-center gap-3 mb-4">
            <label className="flex items-center gap-2">
              <input type="checkbox" checked={playAI} onChange={e=>setPlayAI(e.target.checked)} />
              <span>Play vs AI (AI plays O)</span>
            </label>
            {playAI && (
              <select
                className="p-2 rounded border border-gray-300 bg-white text-gray-900
                           dark:bg-slate-800 dark:border-slate-600 dark:text-slate-100"
                value={difficulty} onChange={e=>setDifficulty(e.target.value)}>
                <option>Beginner</option>
                <option>Intermediate</option>
                <option>Expert</option>
              </select>
            )}
            <label className="flex items-center gap-2 ml-auto">
              <input type="checkbox" checked={soundOn} onChange={e=>setSoundOn(e.target.checked)} />
              <span>Sound</span>
            </label>
            <button
              onClick={()=>setDarkMode(v=>!v)}
              className="px-3 py-2 rounded bg-gray-700 text-white hover:bg-gray-600
                         dark:bg-slate-600 dark:hover:bg-slate-500">
              {themeBtnText}
            </button>
          </div>

          <div className="grid grid-cols-3 gap-3 mb-4">
            {board.map((cell,idx)=>(
              <button
                key={idx}
                onClick={()=>onCellClick(idx)}
                disabled={gameOver || (playAI && !xIsNext)}
                className={`aspect-square rounded-lg shadow cell-animate border
                            bg-white border-gray-300
                            dark:bg-slate-700 dark:border-slate-600
                            flex items-center justify-center text-6xl font-extrabold
                            ${winningLine.includes(idx) ? 'border-4 border-green-800 dark:border-green-400' : ''}`}
                style={{color: cell==="X" ? colorX : colorO}}>
                <span className={`mark-3d ${winningLine.includes(idx) ? 'win-spin' : (justPlaced===idx ? 'pop' : '')}`}>
                  {cell}
                </span>
              </button>
            ))}
          </div>

          <div className="flex gap-3">
            <button onClick={nextRound} className="flex-1 py-3 rounded bg-blue-600 text-white font-semibold hover:bg-blue-500">
              Next Round
            </button>
          </div>
        </div>

        {/* RIGHT: Sidebar / Scoreboard with tallies */}
        <aside className="w-full lg:w-80 lg:min-w-72 border rounded-xl p-4 bg-white/70 backdrop-blur
                          dark:bg-slate-800/60 dark:border-slate-700">
          {/* Player 1 */}
          <div className="mb-5">
            <div className="flex items-center gap-2 mb-2">
              <span className="inline-flex items-center gap-1 px-2 py-1 rounded bg-white border border-gray-300 text-gray-900
                               dark:bg-slate-800 dark:border-slate-600 dark:text-slate-100">
                <span style={{color:colorX}} className="font-extrabold">X</span>
              </span>
              <input
                className="flex-1 p-2 rounded border border-gray-300 bg-white placeholder-gray-400 text-gray-900
                           dark:bg-slate-800 dark:border-slate-600 dark:text-slate-100 dark:placeholder-slate-400"
                value={player1} onChange={e=>setPlayer1(e.target.value)} placeholder="Player 1"/>
              <input type="color" className="w-8 h-8 rounded" value={colorX} onChange={e=>setColorX(e.target.value)}/>
            </div>
            <div className="text-sm opacity-80 mb-1">Score: {scores[player1]||0}</div>
            <Tally count={scores[player1]||0} color={colorX} />
          </div>

          {/* Player 2 */}
          <div className="mb-6">
            <div className="flex items-center gap-2 mb-2">
              <span className="inline-flex items-center gap-1 px-2 py-1 rounded bg-white border border-gray-300 text-gray-900
                               dark:bg-slate-800 dark:border-slate-600 dark:text-slate-100">
                <span style={{color:colorO}} className="font-extrabold">O</span>
              </span>
              <input
                className="flex-1 p-2 rounded border border-gray-300 bg-white placeholder-gray-400 text-gray-900
                           dark:bg-slate-800 dark:border-slate-600 dark:text-slate-100 dark:placeholder-slate-400"
                value={player2} onChange={e=>setPlayer2(e.target.value)} placeholder="Player 2"/>
              <input type="color" className="w-8 h-8 rounded" value={colorO} onChange={e=>setColorO(e.target.value)}/>
            </div>
            <div className="text-sm opacity-80 mb-1">Score: {scores[player2]||0}</div>
            <Tally count={scores[player2]||0} color={colorO} />
          </div>

          {/* Streak Leaderboard */}
          <div className="mb-4">
            <h3 className="font-bold mb-1">Win Streaks</h3>
            {Object.keys(streaks).length===0 ? (
              <p className="text-sm opacity-70">No streaks yet.</p>
            ) : (
              Object.entries(streaks).sort((a,b)=>b[1]-a[1]).map(([name,st])=>(
                <div key={name} className="text-sm">{name}: {st}</div>
              ))
            )}
          </div>

          <div className="flex gap-2">
            <button onClick={resetScores} className="flex-1 py-2 rounded bg-rose-600 text-white font-semibold hover:bg-rose-500">
              Reset Scores
            </button>
          </div>
        </aside>
      </div>
    </div>
  );
}

ReactDOM.createRoot(document.getElementById("root")).render(<TicTacToe/>);
</script>
</body>
</html>
