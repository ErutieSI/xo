<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
<title>Tic Tac Toe Deluxe</title>
<script src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script src="https://cdn.tailwindcss.com"></script>
<script>tailwind.config={darkMode:'class'};</script>
<style>
  html,body { height:100%; }
  .cell-animate{transition:transform .2s ease}
  .cell-animate:active{transform:scale(.96)}
  @keyframes spin3D{0%{transform:rotateY(0)}100%{transform:rotateY(360deg)}}
  .win-spin{animation:spin3D 1s linear infinite;display:inline-block}
  @keyframes popAnim{0%{transform:scale(.5);opacity:0}60%{transform:scale(1.2);opacity:1}100%{transform:scale(1)}}
  .pop{animation:popAnim .22s ease;display:inline-block;will-change:transform}
  .mark-3d{
    text-shadow:
      0 1px 0 rgba(0,0,0,.25),
      0 2px 0 rgba(0,0,0,.20),
      0 3px 0 rgba(0,0,0,.15),
      0 4px 0 rgba(0,0,0,.10);
    transform: translateZ(0);
  }
  /* Stable mark size so cells donâ€™t reflow */
  .mark-size { font-size: clamp(42px, 9vmin, 96px); line-height: 1; }
</style>
</head>
<body class="min-h-screen bg-gray-50 text-gray-900 dark:bg-slate-900 dark:text-slate-100">
<div id="root" class="w-full"></div>

<script type="text/babel">
const { useState, useEffect, useMemo, useRef } = React;

/* --- Tally SVG --- */
function Tally({ count, color }) {
  const groups = Math.floor(count / 5);
  const rem = count % 5;
  const One = ({ n }) => {
    const w=48,h=28,xs=[6,14,22,30];
    return (
      <svg width={w} height={h} viewBox={`0 0 ${w} ${h}`} className="mr-1">
        {xs.slice(0, Math.min(n,4)).map((x,i)=>(
          <line key={i} x1={x} y1="4" x2={x} y2="24" stroke={color} strokeWidth="3" strokeLinecap="round" />
        ))}
        {n===5 && <line x1="3" y1="23" x2="33" y2="5" stroke={color} strokeWidth="3" strokeLinecap="round" />}
      </svg>
    );
  };
  return (
    <div className="flex flex-wrap items-center">
      {Array.from({length: groups}).map((_,i)=><One key={i} n={5} />)}
      {rem>0 && <One n={rem} />}
    </div>
  );
}

function TicTacToe(){
  const EMPTY = Array(9).fill(null);

  // Board/turn & starter
  const [board, setBoard] = useState(EMPTY);
  const [xIsNext, setXIsNext] = useState(true);
  const [starterMark, setStarterMark] = useState('X');

  // Players (Human X; if AI enabled, AI plays O)
  const [player1, setPlayer1] = useState(localStorage.getItem("player1")||"Player 1"); // X
  const [player2, setPlayer2] = useState(localStorage.getItem("player2")||"Player 2"); // O (-> "AI" when AI on)
  const [colorX, setColorX]   = useState(localStorage.getItem("colorX")||"#06b6d4");
  const [colorO, setColorO]   = useState(localStorage.getItem("colorO")||"#3b82f6");

  // Meta
  const [scores, setScores]   = useState(JSON.parse(localStorage.getItem("scores"))||{});
  const [streaks, setStreaks] = useState(JSON.parse(localStorage.getItem("streaks"))||{});
  const [streakHolder, setStreakHolder] = useState(null);
  const [currentStreak, setCurrentStreak] = useState(0);
  const [playAI, setPlayAI] = useState(localStorage.getItem("playAI")==="true");
  const [difficulty, setDifficulty] = useState(localStorage.getItem("difficulty")||"Beginner");
  const [darkMode, setDarkMode] = useState(localStorage.getItem("theme")==="dark");
  const [winningLine, setWinningLine] = useState([]);
  const [justPlaced, setJustPlaced] = useState(null);
  const [statusMsg, setStatusMsg] = useState("");

  // Sounds
  const [soundOn, setSoundOn] = useState(localStorage.getItem("soundOn")!=="false");
  const audioCtxRef = useRef(null);
  function ensureAudio(){
    if (!audioCtxRef.current) audioCtxRef.current = new (window.AudioContext||window.webkitAudioContext)();
    if (audioCtxRef.current.state === "suspended") audioCtxRef.current.resume();
  }
  function beep(freq=440, dur=120, type='sine', vol=0.05){
    if (!soundOn) return;
    ensureAudio();
    const ctx = audioCtxRef.current;
    const o = ctx.createOscillator(); const g = ctx.createGain();
    o.type = type; o.frequency.value = freq; g.gain.value = vol;
    o.connect(g); g.connect(ctx.destination);
    const now = ctx.currentTime;
    o.start(now);
    g.gain.setValueAtTime(vol, now);
    g.gain.exponentialRampToValueAtTime(0.0001, now + dur/1000);
    o.stop(now + dur/1000 + 0.01);
  }
  function moveSound(mark){ beep(mark==='X' ? 880 : 660, 90, 'triangle', 0.04); }
  function drawSound(){ beep(440,120); setTimeout(()=>beep(392,120),120); }
  function winSound(){ beep(523.25,110); setTimeout(()=>beep(659.25,110),110); setTimeout(()=>beep(783.99,160),220); }

  // Persist
  useEffect(()=>{
    localStorage.setItem("player1",player1);
    localStorage.setItem("player2",player2);
    localStorage.setItem("colorX",colorX);
    localStorage.setItem("colorO",colorO);
    localStorage.setItem("scores",JSON.stringify(scores));
    localStorage.setItem("streaks",JSON.stringify(streaks));
    localStorage.setItem("playAI",playAI);
    localStorage.setItem("difficulty",difficulty);
    localStorage.setItem("theme",darkMode?"dark":"light");
    localStorage.setItem("soundOn", String(soundOn));
  },[player1,player2,colorX,colorO,scores,streaks,playAI,difficulty,darkMode,soundOn]);

  useEffect(()=>{ document.documentElement.classList.toggle("dark",darkMode); },[darkMode]);

  // When AI mode is turned on, default Player 2 name to "AI"
  useEffect(()=>{
    if (playAI) setPlayer2("AI");
  }, [playAI]);

  function vibrate(ms){ if (navigator.vibrate) navigator.vibrate(ms); }

  // Winner detection
  function calculateWinner(brd){
    const lines = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
    for (const [i,j,k] of lines){
      if (brd[i] && brd[i]===brd[j] && brd[i]===brd[k]) return {winner: brd[i], line:[i,j,k]};
    }
    return null;
  }

  const result = useMemo(()=>calculateWinner(board),[board]);
  const isDraw = useMemo(()=>!result && !board.includes(null),[result,board]);
  const gameOver = !!result || isDraw;

  // AI helpers
  function blockOrWinMove(mark, opp, brd){
    const lines = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
    for (const [i,j,k] of lines){ const L=[brd[i],brd[j],brd[k]]; if (L.filter(v=>v===mark).length===2 && L.includes(null)) return [i,j,k][L.indexOf(null)]; }
    for (const [i,j,k] of lines){ const L=[brd[i],brd[j],brd[k]]; if (L.filter(v=>v===opp ).length===2 && L.includes(null)) return [i,j,k][L.indexOf(null)]; }
    return null;
  }

  function minimax(brd, isMax, ai, human){
    const r = calculateWinner(brd);
    if (r?.winner===ai) return {score:1};
    if (r?.winner===human) return {score:-1};
    if (!brd.includes(null)) return {score:0};
    let best = {score: isMax? -Infinity : Infinity, move:null};
    for (let idx=0; idx<9; idx++){
      if (!brd[idx]){
        brd[idx] = isMax ? ai : human;
        const s = minimax(brd, !isMax, ai, human).score;
        brd[idx] = null;
        if (isMax ? s>best.score : s<best.score) best = {score:s, move:idx};
      }
    }
    return best;
  }

  function aiChooseMove(currentBoard){
    const ai='O', human='X';
    let move=null;
    if (difficulty==="Expert"){
      move = minimax([...currentBoard], true, ai, human).move;
    } else {
      // Beginner: 50% random / 50% block-or-win
      // Intermediate: 25% random / 75% block-or-win
      const randomChance = (difficulty==="Beginner") ? 0.50 : 0.25;
      if (Math.random() < randomChance){
        const empty = currentBoard.map((v,i)=>v?null:i).filter(v=>v!==null);
        move = empty[Math.floor(Math.random()*empty.length)];
      } else {
        move = blockOrWinMove(ai, human, currentBoard);
        if (move===null){
          const empty = currentBoard.map((v,i)=>v?null:i).filter(v=>v!==null);
          move = empty[Math.floor(Math.random()*empty.length)];
        }
      }
    }
    return move;
  }

  // AI acts only when AI's turn (O), AI mode on, and game not over
  useEffect(()=>{
    if (!playAI || gameOver || xIsNext) return;
    const id = setTimeout(()=>{
      const move = aiChooseMove(board);
      if (move!=null) placeMark(move);
    }, 260);
    return ()=>clearTimeout(id);
  }, [board, xIsNext, playAI, gameOver, difficulty]);

  function endRound(r){
    if (r){
      vibrate(110); winSound();
      setWinningLine(r.line);
      const winnerName = r.winner==="X" ? player1 : player2;
      setStatusMsg(`${winnerName} wins!`);
      setScores(s=>({...s, [winnerName]:(s[winnerName]||0)+1}));
      if (streakHolder===winnerName) setCurrentStreak(cs=>cs+1);
      else { setStreakHolder(winnerName); setCurrentStreak(1); }
      setStreaks(st=>({...st, [winnerName]:Math.max(st[winnerName]||0, (streakHolder===winnerName? currentStreak+1 : 1))}));
      setStarterMark(r.winner);
    } else {
      vibrate(60); drawSound();
      setStatusMsg(`It's a draw.`);
      setStarterMark(m => (m==='X' ? 'O' : 'X'));
    }
  }

  function placeMark(i){
    if (board[i] || gameOver) return;
    const next = [...board];
    const mark = xIsNext ? "X" : "O";
    next[i] = mark;
    setBoard(next);
    setJustPlaced(i);
    moveSound(mark);

    const r = calculateWinner(next);
    if (r || !next.includes(null)){ endRound(r); return; }
    setXIsNext(v=>!v);
  }

  // PvP: both players click; AI mode: only human (X) clicks
  function onCellClick(i){
    if (gameOver) return;
    if (playAI){
      if (xIsNext) placeMark(i);
    } else {
      placeMark(i);
    }
  }

  function nextRound(){
    setBoard(EMPTY);
    setWinningLine([]);
    setJustPlaced(null);
    setStatusMsg("");
    setXIsNext(starterMark==='X');
  }

  // New: Reset Game button (clears current board/round; does not touch scores)
  function resetGame(){
    setBoard(EMPTY);
    setWinningLine([]);
    setJustPlaced(null);
    setStatusMsg("");
    setXIsNext(true);
    setStarterMark('X');
  }

  function resetScores(){
    setScores({});
    setStreaks({});
    setCurrentStreak(0);
    setStreakHolder(null);
  }

  const turnName = xIsNext ? player1 : player2;
  const themeBtnText = darkMode ? "Switch to Light Mode" : "Switch to Dark Mode";

  const turnOverlayClass =
    "pointer-events-none text-5xl sm:text-6xl font-extrabold tracking-wide select-none " +
    "text-gray-700/15 dark:text-slate-100/15";
  const resultOverlayClass =
    "pointer-events-none text-4xl sm:text-5xl font-extrabold tracking-wide select-none " +
    "text-gray-800/65 dark:text-slate-100/70";

  return (
    <div className="w-full px-4 py-4 md:py-6 lg:py-8">
      <div className="max-w-6xl mx-auto flex flex-col lg:flex-row gap-6 items-start">
        {/* LEFT: Board */}
        <div className="flex-1 w-full">
          <div className="relative mx-auto" style={{ width: 'min(94vw, 78vh)', maxWidth:'820px' }}>
            {/* Turn overlay (click-through) */}
            {!gameOver && (
              <div className="absolute inset-0 flex items-center justify-center z-10 pointer-events-none">
                <div className={turnOverlayClass}>{turnName}</div>
              </div>
            )}
            {/* Result overlay */}
            {gameOver && (
              <div className="absolute inset-0 flex flex-col items-center justify-center z-20">
                <div className={resultOverlayClass}>
                  {result ? `${result.winner==='X'?player1:player2} wins!` : 'Draw'}
                </div>
                <button
                  onClick={nextRound}
                  className="mt-4 px-4 py-2 rounded bg-blue-600 text-white font-semibold hover:bg-blue-500 pointer-events-auto"
                >
                  Start New Game
                </button>
              </div>
            )}

            {/* Grid: fixed height; cells fill; prevent overflow shifts */}
            <div className="grid grid-cols-3 grid-rows-3 gap-3 h-[min(94vw,78vh)]">
              {board.map((cell,idx)=>(
                <button
                  key={idx}
                  onClick={()=>onCellClick(idx)}
                  disabled={gameOver || (playAI && !xIsNext)}
                  className={`relative rounded-xl shadow cell-animate border overflow-hidden
                              bg-white border-gray-300
                              dark:bg-slate-700 dark:border-slate-600
                              flex items-center justify-center font-extrabold
                              ${winningLine.includes(idx) ? 'border-4 border-green-800 dark:border-green-400' : ''}`}
                  style={{color: cell==="X" ? colorX : colorO}}
                >
                  <span className={`mark-3d mark-size ${winningLine.includes(idx) ? 'win-spin' : (justPlaced===idx ? 'pop' : '')}`}>
                    {cell}
                  </span>
                </button>
              ))}
            </div>
          </div>
        </div>

        {/* RIGHT: Sidebar */}
        <aside className="w-full lg:w-80 lg:min-w-72 border rounded-xl p-4 bg-white/70 backdrop-blur
                          dark:bg-slate-800/60 dark:border-slate-700">
          <div className="mb-4">
            <div className="flex items-center gap-2 mb-2">
              <span className="inline-flex items-center gap-1 px-2 py-1 rounded bg-white border border-gray-300 text-gray-900
                               dark:bg-slate-800 dark:border-slate-600 dark:text-slate-100">
                <span style={{color:colorX}} className="font-extrabold">X</span>
              </span>
              <input
                className="flex-1 p-2 rounded border border-gray-300 bg-white placeholder-gray-400 text-gray-900
                           dark:bg-slate-800 dark:border-slate-600 dark:text-slate-100 dark:placeholder-slate-400"
                value={player1} onChange={e=>setPlayer1(e.target.value)} placeholder="Player 1"/>
              <input type="color" className="w-8 h-8 rounded" value={colorX} onChange={e=>setColorX(e.target.value)}/>
            </div>
            <div className="flex items-center gap-2">
              <span className="inline-flex items-center gap-1 px-2 py-1 rounded bg-white border border-gray-300 text-gray-900
                               dark:bg-slate-800 dark:border-slate-600 dark:text-slate-100">
                <span style={{color:colorO}} className="font-extrabold">O</span>
              </span>
              <input
                className="flex-1 p-2 rounded border border-gray-300 bg-white placeholder-gray-400 text-gray-900
                           dark:bg-slate-800 dark:border-slate-600 dark:text-slate-100 dark:placeholder-slate-400"
                value={player2} onChange={e=>setPlayer2(e.target.value)} placeholder="Player 2"/>
              <input type="color" className="w-8 h-8 rounded" value={colorO} onChange={e=>setColorO(e.target.value)}/>
            </div>
          </div>

          <div className="mb-4 space-y-3">
            <div className="flex items-center gap-2">
              <input id="ai" type="checkbox" checked={playAI} onChange={e=>setPlayAI(e.target.checked)} />
              <label htmlFor="ai">Play vs AI (AI is O)</label>
            </div>
            {playAI && (
              <select
                className="w-full p-2 rounded border border-gray-300 bg-white text-gray-900
                           dark:bg-slate-800 dark:border-slate-600 dark:text-slate-100"
                value={difficulty} onChange={e=>setDifficulty(e.target.value)}>
                <option>Beginner</option>
                <option>Intermediate</option>
                <option>Expert</option>
              </select>
            )}
            <div className="flex items-center gap-2">
              <input id="sound" type="checkbox" checked={localStorage.getItem("soundOn")!=="false"} onChange={e=>{localStorage.setItem("soundOn", String(e.target.checked)); location.reload();}} />
              <label htmlFor="sound">Sound</label>
              <button
                onClick={()=>setDarkMode(v=>!v)}
                className="ml-auto px-3 py-2 rounded bg-gray-700 text-white hover:bg-gray-600
                           dark:bg-slate-600 dark:hover:bg-slate-500">
                {darkMode ? "Switch to Light Mode" : "Switch to Dark Mode"}
              </button>
            </div>
          </div>

          {/* New: Reset Game */}
          <div className="flex gap-2 mb-4">
            <button onClick={resetGame} className="flex-1 py-2 rounded bg-amber-600 text-white font-semibold hover:bg-amber-500">
              Reset Game
            </button>
            <button onClick={resetScores} className="flex-1 py-2 rounded bg-rose-600 text-white font-semibold hover:bg-rose-500">
              Reset Scores
            </button>
          </div>

          <div className="mb-4">
            <h3 className="font-bold mb-1">Scores</h3>
            <div className="mb-3">
              <div className="text-sm opacity-90 mb-1">{player1}: <span className="font-semibold">{scores[player1]||0}</span></div>
              <Tally count={scores[player1]||0} color={colorX} />
            </div>
            <div className="mb-3">
              <div className="text-sm opacity-90 mb-1">{player2}: <span className="font-semibold">{scores[player2]||0}</span></div>
              <Tally count={scores[player2]||0} color={colorO} />
            </div>
          </div>

          <div>
            <h3 className="font-bold mb-1">Win Streaks</h3>
            {Object.keys(streaks).length===0 ? (
              <p className="text-sm opacity-70">No streaks yet.</p>
            ) : (
              Object.entries(streaks).sort((a,b)=>b[1]-a[1]).map(([name,st])=>(
                <div key={name} className="text-sm">{name}: {st}</div>
              ))
            )}
          </div>
        </aside>
      </div>
    </div>
  );
}

ReactDOM.createRoot(document.getElementById("root")).render(<TicTacToe/>);
</script>
</body>
</html>
